;; Represents the possible widths of an element when used in an operation.
(type VecElementWidth (enum
  (E8)
  (E16)
  (E32)
  (E64)
))

;; Vector Register Group Multiplier (LMUL)
;;
;; The LMUL setting specifies how we should group registers together. LMUL can
;; also be a fractional value, reducing the number of bits used in a single
;; vector register. Fractional LMUL is used to increase the number of effective
;; usable vector register groups when operating on mixed-width values.
(type VecLmul (enum
  (LmulF8)
  (LmulF4)
  (LmulF2)
  (Lmul1)
  (Lmul2)
  (Lmul4)
  (Lmul8)
))

;; Tail Mode
;;
;; The tail mode specifies how the tail elements of a vector register are handled.
(type VecTailMode (enum
  ;; Tail Agnostic means that the tail elements are left in an undefined state.
  (Agnostic)
  ;; Tail Undisturbed means that the tail elements are left in their original values.
  (Undisturbed)
))

;; Mask Mode
;;
;; The mask mode specifies how the masked elements of a vector register are handled.
(type VecMaskMode (enum
  ;; Mask Agnostic means that the masked out elements are left in an undefined state.
  (Agnostic)
  ;; Mask Undisturbed means that the masked out elements are left in their original values.
  (Undisturbed)
))

;; Application Vector Length (AVL)
;;
;; This setting specifies the number of elements that are going to be processed
;; in a single instruction. Note: We may end up processing fewer elements than
;; the AVL setting, if they don't fit in a single register.
(type VecAvl (enum
  ;; Static AVL emits a `vsetivli` that uses a constant value
  (Static (size UImm5))
  ;; TODO: Add a dynamic, register based AVL mode when we are able to properly test it
))

(type VType (primitive VType))
(type VState (primitive VState))


;; Vector Opcode Category
;;
;; These categories are used to determine the type of operands that are allowed in the
;; instruction.
(type VecOpCategory (enum
  (OPIVV)
  (OPFVV)
  (OPMVV)
  (OPIVI)
  (OPIVX)
  (OPFVF)
  (OPMVX)
  (OPCFG)
))

;; Vector Opcode Masking
;;
;; When masked, the instruction will only operate on the elements that are dictated by
;; the mask register. Currently this is always fixed to v0.
(type VecOpMasking (enum
  (Enabled)
  (Disabled)
))

;; Register to Register ALU Ops
(type VecAluOpRRR (enum
  ;; Vector-Vector Opcodes
  (VaddVV)
  (VsubVV)
  (VmulVV)
  (VmulhVV)
  (VmulhuVV)
  (VandVV)
  (VorVV)
  (VxorVV)
  (VfaddVV)
  (VfsubVV)
  (VfmulVV)
  (VfdivVV)
  (VfsgnjnVV)

  ;; Vector-Scalar Opcodes
  (VaddVX)
  (VsubVX)
  (VrsubVX)
  (VslidedownVX)
  (VfaddVF)
  (VfsubVF)
  (VfrsubVF)
  (VfmulVF)
  (VfdivVF)
  (VfrdivVF)
))

;; Register-Imm ALU Ops
(type VecAluOpRRImm5 (enum
  ;; Regular VI Opcodes
  (VaddVI)
  (VrsubVI)
  (VslidedownVI)
))

;; Imm only ALU Ops
(type VecAluOpRImm5 (enum
  (VmvVI)
))

;; These are all of the special cases that have weird encodings. They are all
;; single source, single destination instructions, and usually use one of
;; the two source registers as auxiliary encoding space.
(type VecAluOpRR (enum
  (VmvSX)
  (VmvXS)
  (VfmvSF)
  (VfmvFS)
  ;; vmv.v* is special in that vs2 must be v0 (and is ignored) otherwise the instruction is illegal.
  (VmvVV)
  (VmvVX)
  (VfmvVF)
  (VfsqrtV)
))

;; Returns the canonical destination type for a VecAluOpRRImm5.
(decl pure vec_alu_rr_dst_type (VecAluOpRR) Type)
(extern constructor vec_alu_rr_dst_type vec_alu_rr_dst_type)


;; Vector Addressing Mode
(type VecAMode (enum
  ;; Vector unit-stride operations access elements stored contiguously in memory
  ;; starting from the base effective address.
  (UnitStride
    (base AMode))
  ;; TODO: Constant Stride
  ;; TODO: Indexed Operations
))


;; Builds a static VState matching a SIMD type.
;; The VState is guaranteed to be static with AVL set to the number of lanes.
;; Element size is set to the size of the type.
;; LMUL is set to 1.
;; Tail mode is set to agnostic.
;; Mask mode is set to agnostic.
(decl pure vstate_from_type (Type) VState)
(extern constructor vstate_from_type vstate_from_type)
(convert Type VState vstate_from_type)

;; Extracts an element width from a SIMD type.
(decl pure element_width_from_type (Type) VecElementWidth)
(rule (element_width_from_type ty)
  (if-let $I8 (lane_type ty))
  (VecElementWidth.E8))
(rule (element_width_from_type ty)
  (if-let $I16 (lane_type ty))
  (VecElementWidth.E16))
(rule (element_width_from_type ty)
  (if-let $I32 (lane_type ty))
  (VecElementWidth.E32))
(rule (element_width_from_type ty)
  (if-let $F32 (lane_type ty))
  (VecElementWidth.E32))
(rule (element_width_from_type ty)
  (if-let $I64 (lane_type ty))
  (VecElementWidth.E64))
(rule (element_width_from_type ty)
  (if-let $F64 (lane_type ty))
  (VecElementWidth.E64))

(decl pure min_vec_reg_size () u64)
(extern constructor min_vec_reg_size min_vec_reg_size)

;; An extractor that matches any type that is known to fit in a single vector
;; register.
(decl ty_vec_fits_in_register (Type) Type)
(extern extractor ty_vec_fits_in_register ty_vec_fits_in_register)

;;;; Instruction Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; As noted in the RISC-V Vector Extension Specification, rs2 is the first
;; source register and rs1 is the second source register. This is the opposite
;; of the usual RISC-V register order.
;; See Section 10.1 of the RISC-V Vector Extension Specification.

;; Helper for emitting `MInst.VecAluRRR` instructions.
(decl vec_alu_rrr (VecAluOpRRR Reg Reg VState) Reg)
(rule (vec_alu_rrr op vs2 vs1 vstate)
      (let ((vd WritableReg (temp_writable_reg $I8X16))
            (_ Unit (emit (MInst.VecAluRRR op vd vs2 vs1 vstate))))
        vd))

;; Helper for emitting `MInst.VecAluRRImm5` instructions.
(decl vec_alu_rr_imm5 (VecAluOpRRImm5 Reg Imm5 VState) Reg)
(rule (vec_alu_rr_imm5 op vs2 imm vstate)
      (let ((vd WritableReg (temp_writable_reg $I8X16))
            (_ Unit (emit (MInst.VecAluRRImm5 op vd vs2 imm vstate))))
        vd))

;; Helper for emitting `MInst.VecAluRRImm5` instructions where the immediate
;; is zero extended instead of sign extended.
(decl vec_alu_rr_uimm5 (VecAluOpRRImm5 Reg UImm5 VState) Reg)
(rule (vec_alu_rr_uimm5 op vs2 imm vstate)
      (vec_alu_rr_imm5 op vs2 (uimm5_bitcast_to_imm5 imm) vstate))

;; Helper for emitting `MInst.VecAluRRImm5` instructions that use the Imm5 as
;; auxiliary encoding space.
(decl vec_alu_rr (VecAluOpRR Reg VState) Reg)
(rule (vec_alu_rr op vs vstate)
      (let ((vd WritableReg (temp_writable_reg (vec_alu_rr_dst_type op)))
            (_ Unit (emit (MInst.VecAluRR op vd vs vstate))))
        vd))

;; Helper for emitting `MInst.VecAluRImm5` instructions.
(decl vec_alu_r_imm5 (VecAluOpRImm5 Imm5 VState) Reg)
(rule (vec_alu_r_imm5 op imm vstate)
      (let ((vd WritableReg (temp_writable_reg $I8X16))
            (_ Unit (emit (MInst.VecAluRImm5 op vd imm vstate))))
        vd))

;; Helper for emitting `MInst.VecLoad` instructions.
(decl vec_load (VecElementWidth VecAMode MemFlags VState) Reg)
(rule (vec_load eew from flags vstate)
      (let ((vd WritableReg (temp_writable_reg $I8X16))
            (_ Unit (emit (MInst.VecLoad eew vd from flags vstate))))
        vd))

;; Helper for emitting `MInst.VecStore` instructions.
(decl vec_store (VecElementWidth VecAMode Reg MemFlags VState) InstOutput)
(rule (vec_store eew to from flags vstate)
      (side_effect
        (SideEffectNoResult.Inst (MInst.VecStore eew to from flags vstate))))

;; Helper for emitting the `vadd.vv` instruction.
(decl rv_vadd_vv (Reg Reg VState) Reg)
(rule (rv_vadd_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VaddVV) vs2 vs1 vstate))

;; Helper for emitting the `vadd.vx` instruction.
(decl rv_vadd_vx (Reg Reg VState) Reg)
(rule (rv_vadd_vx vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VaddVX) vs2 vs1 vstate))

;; Helper for emitting the `vadd.vi` instruction.
(decl rv_vadd_vi (Reg Imm5 VState) Reg)
(rule (rv_vadd_vi vs2 imm vstate)
  (vec_alu_rr_imm5 (VecAluOpRRImm5.VaddVI) vs2 imm vstate))

;; Helper for emitting the `vsub.vv` instruction.
(decl rv_vsub_vv (Reg Reg VState) Reg)
(rule (rv_vsub_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VsubVV) vs2 vs1 vstate))

;; Helper for emitting the `vsub.vx` instruction.
(decl rv_vsub_vx (Reg Reg VState) Reg)
(rule (rv_vsub_vx vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VsubVX) vs2 vs1 vstate))

;; Helper for emitting the `vrsub.vx` instruction.
(decl rv_vrsub_vx (Reg Reg VState) Reg)
(rule (rv_vrsub_vx vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VrsubVX) vs2 vs1 vstate))

;; Helper for emitting the `vneg.v` pseudo-instruction.
(decl rv_vneg_v (Reg VState) Reg)
(rule (rv_vneg_v vs2 vstate)
  (vec_alu_rrr (VecAluOpRRR.VrsubVX) vs2 (zero_reg) vstate))

;; Helper for emitting the `vrsub.vi` instruction.
(decl rv_vrsub_vi (Reg Imm5 VState) Reg)
(rule (rv_vrsub_vi vs2 imm vstate)
  (vec_alu_rr_imm5 (VecAluOpRRImm5.VrsubVI) vs2 imm vstate))

;; Helper for emitting the `vmul.vv` instruction.
(decl rv_vmul_vv (Reg Reg VState) Reg)
(rule (rv_vmul_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VmulVV) vs2 vs1 vstate))

;; Helper for emitting the `vmulh.vv` instruction.
(decl rv_vmulh_vv (Reg Reg VState) Reg)
(rule (rv_vmulh_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VmulhVV) vs2 vs1 vstate))

;; Helper for emitting the `vmulhu.vv` instruction.
(decl rv_vmulhu_vv (Reg Reg VState) Reg)
(rule (rv_vmulhu_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VmulhuVV) vs2 vs1 vstate))

;; Helper for emitting the `vand.vv` instruction.
(decl rv_vand_vv (Reg Reg VState) Reg)
(rule (rv_vand_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VandVV) vs2 vs1 vstate))

;; Helper for emitting the `vor.vv` instruction.
(decl rv_vor_vv (Reg Reg VState) Reg)
(rule (rv_vor_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VorVV) vs2 vs1 vstate))

;; Helper for emitting the `vxor.vv` instruction.
(decl rv_vxor_vv (Reg Reg VState) Reg)
(rule (rv_vxor_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VxorVV) vs2 vs1 vstate))

;; Helper for emitting the `vfadd.vv` instruction.
(decl rv_vfadd_vv (Reg Reg VState) Reg)
(rule (rv_vfadd_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfaddVV) vs2 vs1 vstate))

;; Helper for emitting the `vfadd.vf` instruction.
(decl rv_vfadd_vf (Reg Reg VState) Reg)
(rule (rv_vfadd_vf vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfaddVF) vs2 vs1 vstate))

;; Helper for emitting the `vfsub.vv` instruction.
(decl rv_vfsub_vv (Reg Reg VState) Reg)
(rule (rv_vfsub_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfsubVV) vs2 vs1 vstate))

;; Helper for emitting the `vfsub.vf` instruction.
(decl rv_vfsub_vf (Reg Reg VState) Reg)
(rule (rv_vfsub_vf vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfsubVF) vs2 vs1 vstate))

;; Helper for emitting the `vfrsub.vf` instruction.
(decl rv_vfrsub_vf (Reg Reg VState) Reg)
(rule (rv_vfrsub_vf vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfrsubVF) vs2 vs1 vstate))

;; Helper for emitting the `vfmul.vv` instruction.
(decl rv_vfmul_vv (Reg Reg VState) Reg)
(rule (rv_vfmul_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfmulVV) vs2 vs1 vstate))

;; Helper for emitting the `vfmul.vf` instruction.
(decl rv_vfmul_vf (Reg Reg VState) Reg)
(rule (rv_vfmul_vf vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfmulVF) vs2 vs1 vstate))

;; Helper for emitting the `vfdiv.vv` instruction.
(decl rv_vfdiv_vv (Reg Reg VState) Reg)
(rule (rv_vfdiv_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfdivVV) vs2 vs1 vstate))

;; Helper for emitting the `vfdiv.vf` instruction.
(decl rv_vfdiv_vf (Reg Reg VState) Reg)
(rule (rv_vfdiv_vf vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfdivVF) vs2 vs1 vstate))

;; Helper for emitting the `vfrdiv.vf` instruction.
(decl rv_vfrdiv_vf (Reg Reg VState) Reg)
(rule (rv_vfrdiv_vf vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfrdivVF) vs2 vs1 vstate))

;; Helper for emitting the `vfsgnjn.vv` ("Floating Point Sign Injection Negated") instruction.
;; The output of this instruction is `vs2` with the negated sign bit from `vs1`
(decl rv_vfsgnjn_vv (Reg Reg VState) Reg)
(rule (rv_vfsgnjn_vv vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VfsgnjnVV) vs2 vs1 vstate))

;; Helper for emitting the `vfneg.v` instruction.
;; This instruction is a mnemonic for `vfsgnjn.vv vd, vs, vs`
(decl rv_vfneg_v (Reg VState) Reg)
(rule (rv_vfneg_v vs vstate) (rv_vfsgnjn_vv vs vs vstate))

;; Helper for emitting the `vfsqrt.v` instruction.
;; This instruction splats the F regsiter into all elements of the destination vector.
(decl rv_vfsqrt_v (Reg VState) Reg)
(rule (rv_vfsqrt_v vs vstate)
  (vec_alu_rr (VecAluOpRR.VfsqrtV) vs vstate))

;; Helper for emitting the `vslidedown.vx` instruction.
;; `vslidedown` moves all elements in the vector down by n elements.
;; The top most elements are up to the tail policy.
(decl rv_vslidedown_vx (Reg Reg VState) Reg)
(rule (rv_vslidedown_vx vs2 vs1 vstate)
  (vec_alu_rrr (VecAluOpRRR.VslidedownVX) vs2 vs1 vstate))

;; Helper for emitting the `vslidedown.vi` instruction.
;; Unlike other `vi` instructions the immediate is zero extended.
(decl rv_vslidedown_vi (Reg UImm5 VState) Reg)
(rule (rv_vslidedown_vi vs2 imm vstate)
  (vec_alu_rr_uimm5 (VecAluOpRRImm5.VslidedownVI) vs2 imm vstate))

;; Helper for emitting the `vmv.x.s` instruction.
;; This instruction copies the first element of the source vector to the destination X register.
(decl rv_vmv_xs (Reg VState) Reg)
(rule (rv_vmv_xs vs vstate)
  (vec_alu_rr (VecAluOpRR.VmvXS) vs vstate))

;; Helper for emitting the `vfmv.f.s` instruction.
;; This instruction copies the first element of the source vector to the destination F register.
(decl rv_vfmv_fs (Reg VState) Reg)
(rule (rv_vfmv_fs vs vstate)
  (vec_alu_rr (VecAluOpRR.VfmvFS) vs vstate))

;; Helper for emitting the `vmv.v.x` instruction.
;; This instruction splats the X regsiter into all elements of the destination vector.
(decl rv_vmv_vx (Reg VState) Reg)
(rule (rv_vmv_vx vs vstate)
  (vec_alu_rr (VecAluOpRR.VmvVX) vs vstate))

;; Helper for emitting the `vfmv.v.f` instruction.
;; This instruction splats the F regsiter into all elements of the destination vector.
(decl rv_vfmv_vf (Reg VState) Reg)
(rule (rv_vfmv_vf vs vstate)
  (vec_alu_rr (VecAluOpRR.VfmvVF) vs vstate))

;; Helper for emitting the `vmv.v.i` instruction.
;; This instruction splat's the immediate value into all elements of the destination vector.
(decl rv_vmv_vi (Imm5 VState) Reg)
(rule (rv_vmv_vi imm vstate)
  (vec_alu_r_imm5 (VecAluOpRImm5.VmvVI) imm vstate))

;;;; Multi-Instruction Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(decl gen_extractlane (Type Reg u8) Reg)

;; When extracting lane 0 for floats, we can use `vfmv.f.s` directly.
(rule 3 (gen_extractlane (ty_vec_fits_in_register ty) src 0)
  (if (ty_vector_float ty))
  (rv_vfmv_fs src ty))

;; When extracting lane 0 for integers, we can use `vmv.x.s` directly.
(rule 2 (gen_extractlane (ty_vec_fits_in_register ty) src 0)
  (if (ty_vector_not_float ty))
  (rv_vmv_xs src ty))

;; In the general case, we must first use a `vslidedown` to place the correct lane
;; in index 0, and then use the appropriate `vmv` instruction.
;; If the index fits into a 5-bit immediate, we can emit a `vslidedown.vi`.
(rule 1 (gen_extractlane (ty_vec_fits_in_register ty) src (uimm5_from_u8 idx))
  (gen_extractlane ty (rv_vslidedown_vi src idx ty) 0))

;; Otherwise lower it into an X register.
(rule 0 (gen_extractlane (ty_vec_fits_in_register ty) src idx)
  (gen_extractlane ty (rv_vslidedown_vx src (imm $I64 idx) ty) 0))
